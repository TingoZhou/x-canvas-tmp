<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/EaselJS_16x16.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
	<title>xc v0.1.0 API Documentation : ..\src\lib\createjs\soundjs\WebAudioPlugin.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http:&#x2F;&#x2F;www.createjs.com&#x2F;#!&#x2F;EaselJS"><img src="http:&#x2F;&#x2F;createjs.com&#x2F;resources&#x2F;SuiteIcons&#x2F;EaselJS&#x2F;docs-icon-EaselJS.png" title="xc"></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AlphaMapFilter.html">AlphaMapFilter</a></li>
            
                <li><a href="..&#x2F;classes/AlphaMaskFilter.html">AlphaMaskFilter</a></li>
            
                <li><a href="..&#x2F;classes/Bitmap.html">Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/BitmapAnimation.html">BitmapAnimation</a></li>
            
                <li><a href="..&#x2F;classes/BoxBlurFilter.html">BoxBlurFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorFilter.html">ColorFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrix.html">ColorMatrix</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrixFilter.html">ColorMatrixFilter</a></li>
            
                <li><a href="..&#x2F;classes/Command.html">Command</a></li>
            
                <li><a href="..&#x2F;classes/Container.html">Container</a></li>
            
                <li><a href="..&#x2F;classes/CSSPlugin.html">CSSPlugin</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="..&#x2F;classes/Ease.html">Ease</a></li>
            
                <li><a href="..&#x2F;classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/Filter.html">Filter</a></li>
            
                <li><a href="..&#x2F;classes/Graphics.html">Graphics</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioLoader.html">HTMLAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioPlugin.html">HTMLAudioPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Log.html">Log</a></li>
            
                <li><a href="..&#x2F;classes/Matrix2D.html">Matrix2D</a></li>
            
                <li><a href="..&#x2F;classes/MotionGuidePlugin.html">MotionGuidePlugin</a></li>
            
                <li><a href="..&#x2F;classes/MouseEvent.html">MouseEvent</a></li>
            
                <li><a href="..&#x2F;classes/MovieClip.html">MovieClip</a></li>
            
                <li><a href="..&#x2F;classes/MovieClipPlugin.html">MovieClipPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Shadow.html">Shadow</a></li>
            
                <li><a href="..&#x2F;classes/Shape.html">Shape</a></li>
            
                <li><a href="..&#x2F;classes/Sound.html">Sound</a></li>
            
                <li><a href="..&#x2F;classes/SoundChannel.html">SoundChannel</a></li>
            
                <li><a href="..&#x2F;classes/SoundInstance.html">SoundInstance</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetBuilder.html">SpriteSheetBuilder</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetUtils.html">SpriteSheetUtils</a></li>
            
                <li><a href="..&#x2F;classes/Stage.html">Stage</a></li>
            
                <li><a href="..&#x2F;classes/TagPool.html">TagPool</a></li>
            
                <li><a href="..&#x2F;classes/Text.html">Text</a></li>
            
                <li><a href="..&#x2F;classes/Ticker.html">Ticker</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Touch.html">Touch</a></li>
            
                <li><a href="..&#x2F;classes/Tween.html">Tween</a></li>
            
                <li><a href="..&#x2F;classes/UID.html">UID</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioLoader.html">WebAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioPlugin.html">WebAudioPlugin</a></li>
            
                <li><a href="..&#x2F;classes/xc.class.html">xc.class</a></li>
            
                <li><a href="..&#x2F;classes/xc.module.html">xc.module</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/xc.html">xc</a></li>
            
                <li><a href="..&#x2F;modules/xc.core.html">xc.core</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.html">xc.createjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.easeljs.html">xc.createjs.easeljs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.soundjs.html">xc.createjs.soundjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.tweenjs.html">xc.createjs.tweenjs</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = ..\src\lib\createjs\soundjs\WebAudioPlugin.js      
</script>
<h1 class="file-heading">File:..\src\lib\createjs\soundjs\WebAudioPlugin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
xc.module.define(&quot;xc.createjs.WebAudioPlugin&quot;, function(exports) {

  var Sound = xc.module.require(&quot;xc.createjs.Sound&quot;);
  var SoundInstance = xc.module.require(&quot;xc.createjs.SoundInstance&quot;);

  &#x2F;**
   * WebAudioPlugin&#x27;s SoundInstance implementation.
   *&#x2F;
  var WebAudioSoundInstance = SoundInstance.extend({
    _init: function(src, owner) {
      this.owner = owner;
      this.src = src;
      this.panNode = this.owner.context.createPanner();  &#x2F;&#x2F; allows us to manipulate left and right audio  &#x2F;&#x2F; TODO test how this affects when we have mono audio
      this.gainNode = this.owner.context.createGainNode();  &#x2F;&#x2F; allows us to manipulate instance volume
      this.gainNode.connect(this.panNode);  &#x2F;&#x2F; connect us to our sequence that leads to context.destination
      if (this.owner.isPreloadComplete(this.src)) {
        this.duration = this.owner.arrayBuffers[this.src].duration * 1000;
      }
      this.endedHandler = Sound.proxy(this.handleSoundComplete, this);
      this.readyHandler = Sound.proxy(this.handleSoundReady, this);
      this.stalledHandler = Sound.proxy(this.handleSoundStalled, this);
    },

    soundCompleteTimeout: null,

    startTime: 0,

    &#x2F;**
     * Clean up the instance. Remove references and clean up any additional properties such as timers.
     *
     * @method cleanup
     * @protected
     *&#x2F;
    cleanUp:function () {
      &#x2F;&#x2F; if playbackState is UNSCHEDULED_STATE, then noteON or noteGrainOn has not been called so calling noteOff would throw an error
      if (this.sourceNode &amp;&amp; this.sourceNode.playbackState != this.sourceNode.UNSCHEDULED_STATE) {
        this.sourceNode.noteOff(0);
        this.sourceNode = null; &#x2F;&#x2F; release reference so Web Audio can handle removing references and garbage collection
      }
      if (this.panNode.numberOfOutputs != 0) {
        this.panNode.disconnect(0);
      } &#x2F;&#x2F; this works because we only have one connection, and it returns 0 if we&#x27;ve already disconnected it.
      clearTimeout(this.delayTimeoutId); &#x2F;&#x2F; clear timeout that plays delayed sound
      clearTimeout(this.soundCompleteTimeout);  &#x2F;&#x2F; clear timeout that triggers sound complete
      Sound.playFinished(this);
    },

    &#x2F;&#x2F; Playback has stalled, and therefore failed.
    handleSoundStalled:function (event) {
      this.sendEvent(&quot;failed&quot;);
    },

    &#x2F;&#x2F; The sound is ready for playing
    handleSoundReady:function (event) {
      if (this.offset &gt; this.getDuration()) {
        this.playFailed();
        return;
      } else if (this.offset &lt; 0) {  &#x2F;&#x2F; may not need this check if noteGrainOn ignores negative values, this is not specified in the API http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;webaudio&#x2F;#AudioBufferSourceNode
        this.offset = 0;
      }
      this.playState = Sound.PLAY_SUCCEEDED;
      this.paused = false;
      this.panNode.connect(this.owner.gainNode);  &#x2F;&#x2F; this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.
      &#x2F;&#x2F; WebAudio supports BufferSource, MediaElementSource, and MediaStreamSource.
      &#x2F;&#x2F; NOTE MediaElementSource requires different commands to play, pause, and stop because it uses audio tags.
      &#x2F;&#x2F; The same is assumed for MediaStreamSource, although it may share the same commands as MediaElementSource.
      this.sourceNode = this.owner.context.createBufferSource();
      this.sourceNode.buffer = this.owner.arrayBuffers[this.src];
      this.duration = this.owner.arrayBuffers[this.src].duration * 1000;
      this.sourceNode.connect(this.gainNode);
      this.soundCompleteTimeout = setTimeout(this.endedHandler, (this.sourceNode.buffer.duration - this.offset) * 1000);  &#x2F;&#x2F; NOTE *1000 because WebAudio reports everything in seconds but js uses milliseconds
      this.startTime = this.owner.context.currentTime - this.offset;
      this.sourceNode.noteGrainOn(0, this.offset, this.sourceNode.buffer.duration - this.offset);
    },

    &#x2F;&#x2F; Audio has finished playing. Manually loop it if required.
    &#x2F;&#x2F; called internally by soundCompleteTimeout in WebAudioPlugin
    handleSoundComplete:function (event) {
      this.offset = 0;  &#x2F;&#x2F; have to set this as it can be set by pause during playback
      if (this.remainingLoops != 0) {
        this.remainingLoops--;  &#x2F;&#x2F; NOTE this introduces a theoretical limit on loops = float max size x 2 - 1
        this.handleSoundReady(null);
        if (this.onLoop != null) {
          this.onLoop(this);
        }
        this.sendEvent(&quot;loop&quot;);
        return;
      }
      this.playState = Sound.PLAY_FINISHED;
      if (this.onComplete != null) {
        this.onComplete(this);
      }
      this.sendEvent(&quot;complete&quot;);
      this.cleanUp();
    },

    beginPlaying:function (offset, loop, volume, pan) {
      if (!this.src) {
        return;
      }
      this.offset = offset &#x2F; 1000;  &#x2F;&#x2F;convert ms to sec
      this.remainingLoops = loop;
      this.setVolume(volume);
      this.setPan(pan);
      if (this.owner.isPreloadComplete(this.src)) {
        this.handleSoundReady(null);
        this.onPlaySucceeded &amp;&amp; this.onPlaySucceeded(this);
        this.sendEvent(&quot;succeeded&quot;);
        return 1;
      } else {
        this.playFailed();
        return;
      }
    },

    pause:function () {
      if (!this.paused &amp;&amp; this.playState == Sound.PLAY_SUCCEEDED) {
        this.paused = true;
        this.offset = this.owner.context.currentTime - this.startTime;  &#x2F;&#x2F; this allows us to restart the sound at the same point in playback
        this.sourceNode.noteOff(0);  &#x2F;&#x2F; note this means the sourceNode cannot be reused and must be recreated
        if (this.panNode.numberOfOutputs != 0) {
          this.panNode.disconnect();
        }  &#x2F;&#x2F; this works because we only have one connection, and it returns 0 if we&#x27;ve already disconnected it.
        clearTimeout(this.delayTimeoutId); &#x2F;&#x2F; clear timeout that plays delayed sound
        clearTimeout(this.soundCompleteTimeout);  &#x2F;&#x2F; clear timeout that triggers sound complete
        return true;
      }
      return false;
    },

    resume:function () {
      if (!this.paused) {
        return false;
      }
      this.handleSoundReady(null);
      return true;
    },

    stop:function () {
      this.playState = Sound.PLAY_FINISHED;
      this.cleanUp();
      this.offset = 0;  &#x2F;&#x2F; set audio to start at the beginning
      return true;
    },

    setVolume:function (value) {
      if (Number(value) == null) {
        return false;
      }
      value = Math.max(0, Math.min(1, value));
      this.volume = value;
      this.updateVolume();
      return true;  &#x2F;&#x2F; This is always true because even if the volume is not updated, the value is set
    },

    updateVolume:function () {
      var newVolume = this.muted ? 0 : this.volume;
      if (newVolume != this.gainNode.gain.value) {
        this.gainNode.gain.value = newVolume;
        return true;
      }
      return false;
    },

    setMute:function (value) {
      if (value == null || value == undefined) {
        return false
      }
      this.muted = value;
      this.updateVolume();
      return true;
    },

    setPan:function (value) {
      if (this.owner.capabilities.panning) {
        &#x2F;&#x2F; Note that panning in WebAudioPlugin can support 3D audio, but our implementation does not.
        this.panNode.setPosition(value, 0, -0.5);  &#x2F;&#x2F; z need to be -0.5 otherwise the sound only plays in left, right, or center
        this.pan = value;  &#x2F;&#x2F; Unfortunately panner does not give us a way to access this after it is set http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;webaudio&#x2F;#AudioPannerNode
      } else {
        return false;
      }
    },

    getPosition:function () {
      if (this.paused || this.sourceNode == null) {
        var pos = this.offset;
      } else {
        var pos = this.owner.context.currentTime - this.startTime;
      }
      return pos * 1000; &#x2F;&#x2F; pos in seconds * 1000 to give milliseconds
    },

    setPosition:function (value) {
      this.offset = value &#x2F; 1000; &#x2F;&#x2F; convert milliseconds to seconds
      if (this.sourceNode &amp;&amp; this.sourceNode.playbackState != this.sourceNode.UNSCHEDULED_STATE) {  &#x2F;&#x2F; if playbackState is UNSCHEDULED_STATE, then noteON or noteGrainOn has not been called so calling noteOff would throw an error
        this.sourceNode.noteOff(0);  &#x2F;&#x2F; we need to stop this sound from continuing to play, as we need to recreate the sourceNode to change position
        clearTimeout(this.soundCompleteTimeout);  &#x2F;&#x2F; clear timeout that triggers sound complete
      }  &#x2F;&#x2F; NOTE we cannot just call cleanup because it also calls the Sound function playFinished which releases this instance in SoundChannel
      if (!this.paused &amp;&amp; this.playState == Sound.PLAY_SUCCEEDED) {
        this.handleSoundReady(null);
      }
      return true;
    },

    toString:function () {
      return &quot;[WebAudioPlugin SoundInstance]&quot;;
    }
  });

  &#x2F;**
   * An internal helper class that preloads web audio via XHR. Note that this class and its methods are not documented
   * properly to avoid generating HTML documentation.
   *
   * @class WebAudioLoader
   * @param {String} src The source of the sound to load.
   * @param {Object} owner A reference to the class that created this instance.
   * @constructor
   *&#x2F;
  var WebAudioLoader = xc.class.create({
    _init: function(src, owner) {
      this.src = src;
      this.owner = owner;
    },

    &#x2F;&#x2F; the request object for or XHR2 request
    request: null,

    owner: null,

    progress: -1,

    &#x2F;**
     * The source of the sound to load. Used by callback functions when we return this class.
     *
     * @property src
     * @type {String}
     *&#x2F;
    src: null,

    &#x2F;**
     * The decoded AudioBuffer array that is returned when loading is complete.
     *
     * @property result
     * @type {AudioBuffer}
     * @protected
     *&#x2F;
    result: null,

    &#x2F;**
     * The callback that fires when the load completes. This follows HTML tag naming.
     *
     * @property onload
     * @type {Method}
     *&#x2F;
    onload: null,

    &#x2F;**
     * The callback that fires as the load progresses. This follows HTML tag naming.
     *
     * @property onprogress
     * @type {Method}
     *&#x2F;
    onprogress: null,

    &#x2F;**
     * The callback that fires if the load hits an error.
     *
     * @property onError
     * @type {Method}
     * @protected
     *&#x2F;
    onError: null,

    &#x2F;**
     * Begin loading the content.
     *
     * @method load
     * @param {String} src The path to the sound.
     *&#x2F;
    load: function(src) {
      if (src != null) {
        this.src = src;
      }
      this.request = new XMLHttpRequest();
      this.request.open(&quot;GET&quot;, this.src, true);
      this.request.responseType = &quot;arraybuffer&quot;;
      this.request.onload = Sound.proxy(this.handleLoad, this);
      this.request.onError = Sound.proxy(this.handleError, this);
      this.request.onprogress = Sound.proxy(this.handleProgress, this);
      this.request.send();
    },

    &#x2F;**
     * The loader has reported progress.
     *
     * @method handleProgress
     * @param {Number} loaded The loaded amount.
     * @param {Number} total The total amount.
     * @private
     *&#x2F;
    handleProgress: function(loaded, total) {
      this.progress = loaded &#x2F; total;
      if (this.onprogress == null) {
        return;
      }
      this.onprogress({loaded: loaded, total: total, progress: this.progress});
    },

    &#x2F;**
     * The sound has completed loading.
     *
     * @method handleLoad
     * @protected
     *&#x2F;
    handleLoad: function() {
      s.context.decodeAudioData(this.request.response,
          Sound.proxy(this.handleAudioDecoded, this),
          Sound.proxy(this.handleError, this));
    },

    &#x2F;**
     * The audio has been decoded.
     *
     * @method handleAudioDecoded
     * @protected
     *&#x2F;
    handleAudioDecoded: function(decodedAudio) {
      this.progress = 1;
      this.result = decodedAudio;
      this.owner.addPreloadResults(this.src, this.result);
      this.onload &amp;&amp; this.onload();
    },

    &#x2F;**
     * Errors have been caused by the loader.
     *
     * @method handleError
     * @protected
     *&#x2F;
    handleError: function(evt) {
      this.owner.removeFromPreload(this.src);
      this.onerror &amp;&amp; this.onerror(evt);
    },

    toString: function() {
      return &quot;[WebAudioPlugin WebAudioLoader]&quot;;
    }
  });

  &#x2F;**
   * Play sounds using Web Audio in the browser. The WebAudio plugin has been successfully tested with:
   * &lt;ul&gt;
   *  &lt;li&gt;Google Chrome, version 23+ on OS X and Windows&lt;&#x2F;li&gt;
   *  &lt;li&gt;Safari 6+ on OS X&lt;&#x2F;li&gt;
   *  &lt;li&gt;Mobile Safari on iOS 6+&lt;&#x2F;li&gt;
   * &lt;&#x2F;ul&gt;
   *
   * The WebAudioPlugin is currently the default plugin, and will be used anywhere that it is supported. To change
   * plugin priority, check out the Sound API {{#crossLink &quot;Sound&#x2F;registerPlugins&quot;}}{{&#x2F;crossLink}} method.

   * &lt;h4&gt;Known Browser and OS issues for Web Audio Plugin&lt;&#x2F;h4&gt;
   * &lt;b&gt;Webkit (Chrome and Safari)&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;
   * &lt;ul&gt;
   *  &lt;li&gt;AudioNode.disconnect does not always seem to work. This can cause your file size to grow over time if you are playing a lot of audio files.&lt;&#x2F;li&gt;
   * &lt;&#x2F;ul&gt;
   *
   * &lt;b&gt;iOS 6 limitations&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;
   * &lt;ul&gt;
   *  &lt;li&gt;Sound is initially muted and will only unmute through play being called inside a user initiated event (touch).&lt;&#x2F;li&gt;
   * &lt;&#x2F;ul&gt;
   *
   * @class WebAudioPlugin
   * @constructor
   *&#x2F;
  var WebAudioPlugin = xc.class.create({
    _init: function() {
      this.capabilities = WebAudioPlugin.capabilities;
      this.arrayBuffers = {};
      this.context = WebAudioPlugin.context;
      this.gainNode = WebAudioPlugin.gainNode;
      this.dynamicsCompressorNode = WebAudioPlugin.dynamicsCompressorNode;
    },

    capabilities: null, &#x2F;&#x2F; doc&#x27;d above

    &#x2F;**
     * The web audio context, which WebAudio uses to play audio. All nodes that interact with the WebAudioPlugin
     * need to be created within this context.
     *
     * @property context
     * @type {AudioContext}
     *&#x2F;
    context: null,

    &#x2F;**
     * A DynamicsCompressorNode, which is used to improve sound and prevent audio distortion according to
     * http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;webaudio&#x2F;#DynamicsCompressorNode. It is connected to &lt;code&gt;context.destination&lt;&#x2F;code&gt;.
     *
     * @property dynamicsCompressorNode
     * @type {AudioNode}
     *&#x2F;
    dynamicsCompressorNode: null,

    &#x2F;**
     * A GainNode for controlling master volume. It is connected to &lt;code&gt;dynamicsCompressorNode&lt;&#x2F;code&gt;.
     *
     * @property gainNode
     * @type {AudioGainNode}
     *&#x2F;
    gainNode: null,

    &#x2F;**
     * A hash used internally to store ArrayBuffers, indexed by the source URI used  to load it. This prevents
     * having to load and decode audio files more than once. If a load has been started on a file, &lt;code&gt;arrayBuffers[src]&lt;&#x2F;code&gt;
     * will be set to true. Once load is complete, it is set the the loaded ArrayBuffer instance.
     *
     * @property arrayBuffers
     * @type {Object}
     * @protected
     *&#x2F;
    arrayBuffers: null,

    &#x2F;**
     * Pre-register a sound for preloading and setup. This is called by {{#crossLink &quot;Sound&quot;}}{{&#x2F;crossLink}}.
     * Note that WebAudio provides a &lt;code&gt;WebAudioLoader&lt;&#x2F;code&gt; instance, which &lt;a href=&quot;http:&#x2F;&#x2F;preloadjs.com&quot;&gt;PreloadJS&lt;&#x2F;a&gt;
     * can use to assist with preloading.
     *
     * @method register
     * @param {String} src The source of the audio
     * @param {Number} instances The number of concurrently playing instances to allow for the channel at any time.
     *  Note that the WebAudioPlugin does not manage this property.
     * @return {Object} A result object, containing a &quot;tag&quot; for preloading purposes.
     *&#x2F;
    register: function(src, instances) {
      this.arrayBuffers[src] = true;  &#x2F;&#x2F; This is needed for PreloadJS
      var tag = new WebAudioLoader(src, this);
      return {
        tag: tag
      };
    },

    &#x2F;**
     * Checks if preloading has started for a specific source. If the source is found, we can assume it is loading,
     * or has already finished loading.
     *
     * @method isPreloadStarted
     * @param {String} src The sound URI to check.
     * @return {Boolean}
     *&#x2F;
    isPreloadStarted: function(src) {
      return (this.arrayBuffers[src] != null);
    },

    &#x2F;**
     * Checks if preloading has finished for a specific source. If the source is defined (but not === true), then
     * it has finished loading.
     *
     * @method isPreloadComplete
     * @param {String} src The sound URI to load.
     * @return {Boolean}
     *&#x2F;
    isPreloadComplete: function(src) {
      return (!(this.arrayBuffers[src] == null || this.arrayBuffers[src] == true));
    },

    &#x2F;**
     * Remove a source from our preload list. Note this does not cancel a preload.
     *
     * @method removeFromPreload
     * @param {String} src The sound URI to unload.
     * @return {Boolean}
     *&#x2F;
    removeFromPreload: function(src) {
      delete(this.arrayBuffers[src]);
    },

    &#x2F;**
     * Add loaded results to the preload hash.
     *
     * @method addPreloadResults
     * @param {String} src The sound URI to unload.
     * @param {AudioBuffer} result The reload result.
     * @return {Boolean}
     *&#x2F;
    addPreloadResults: function(src, result) {
      this.arrayBuffers[src] = result;
    },

    &#x2F;**
     * Handles internal preload completion.
     *
     * @method handlePreloadComplete
     * @private
     *&#x2F;
    handlePreloadComplete: function() {
      Sound.sendLoadComplete(this.src);  &#x2F;&#x2F; fire event or callback on Sound
    },

    &#x2F;**
     * Internally preload a sound. Loading uses XHR2 to load an array buffer for use with WebAudio.
     *
     * @method preload
     * @param {String} src The sound URI to load.
     * @param {Object} instance Not used in this plugin.
     * @protected
     *&#x2F;
    preload: function(src, instance) {
      this.arrayBuffers[src] = true;
      var loader = new WebAudioLoader(src, this);
      loader.onload = this.handlePreloadComplete;
      loader.load();
    },

    &#x2F;**
     * Create a sound instance. If the sound has not been preloaded, it is internally preloaded here.
     *
     * @method create
     * @param {String} src The sound source to use.
     * @return {SoundInstance} A sound instance for playback and control.
     *&#x2F;
    create: function(src) {
      if (!this.isPreloadStarted(src)) {
        this.preload(src);
      }
      return new WebAudioSoundInstance(src, this);
    },

    toString: function() {
      return &quot;[WebAudioPlugin]&quot;;
    }
  });

	&#x2F;**
	 * The capabilities of the plugin. This is generated via the &lt;code&gt;&quot;WebAudioPlugin&#x2F;generateCapabilities&lt;&#x2F;code&gt;
	 * method.
   *
	 * @property capabilities
	 * @type {Object}
	 * @default null
	 * @static
	 *&#x2F;
  WebAudioPlugin.capabilities = null;

	&#x2F;**
	 * Determine if the plugin can be used in the current browser&#x2F;OS.
   *
	 * @method isSupported
	 * @return {Boolean} If the plugin can be initialized.
	 * @static
	 *&#x2F;
  WebAudioPlugin.isSupported = function () {
    if (location.protocol == &quot;file:&quot;) { return false; }  &#x2F;&#x2F; Web Audio requires XHR, which is not available locally
    WebAudioPlugin.generateCapabilities();
		if (WebAudioPlugin.context == null) {
			return false;
		}
		return true;
	};

	&#x2F;**
	 * Determine the capabilities of the plugin. Used internally. Please see the Sound API {{#crossLink &quot;Sound&#x2F;getCapabilities&quot;}}{{&#x2F;crossLink}}
	 * method for an overview of plugin capabilities.
   *
	 * @method generateCapabiities
	 * @static
	 * @protected
	 *&#x2F;
  WebAudioPlugin.generateCapabilities = function () {
		if (WebAudioPlugin.capabilities != null) {
			return;
		}
		&#x2F;&#x2F; Web Audio can be in any formats supported by the audio element, from http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;webaudio&#x2F;#AudioContext-section,
		&#x2F;&#x2F; therefore tag is still required for the capabilities check
		var t = document.createElement(&quot;audio&quot;);
		if (t.canPlayType == null) {
			return null;
		}
		&#x2F;&#x2F; This check is first because it&#x27;s what is currently used, but the spec calls for it to be AudioContext so this
		&#x2F;&#x2F; will probably change in time
		if (window.webkitAudioContext) {
      WebAudioPlugin.context = new webkitAudioContext();
		} else if (window.AudioContext) {
      WebAudioPlugin.context = new AudioContext();
		} else {
			return null;
		}
    WebAudioPlugin.capabilities = {
			panning:true,
			volume:true,
			tracks:-1
		};
		&#x2F;&#x2F; determine which extensions our browser supports for this plugin by iterating through Sound.SUPPORTED_EXTENSIONS
		var supportedExtensions = Sound.SUPPORTED_EXTENSIONS;
		var extensionMap = Sound.EXTENSION_MAP;
		for (var i = 0, l = supportedExtensions.length; i &lt; l; i++) {
			var ext = supportedExtensions[i];
			var playType = extensionMap[ext] || ext;
      WebAudioPlugin.capabilities[ext] = (t.canPlayType(&quot;audio&#x2F;&quot; + ext) != &quot;no&quot; &amp;&amp; t.canPlayType(&quot;audio&#x2F;&quot; + ext) != &quot;&quot;) || (t.canPlayType(&quot;audio&#x2F;&quot; + playType) != &quot;no&quot; &amp;&amp; t.canPlayType(&quot;audio&#x2F;&quot; + playType) != &quot;&quot;);
		}
		&#x2F;&#x2F; 0=no output, 1=mono, 2=stereo, 4=surround, 6=5.1 surround.
		&#x2F;&#x2F; See http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;webaudio&#x2F;#AudioChannelSplitter for more details on channels.
		if (WebAudioPlugin.context.destination.numberOfChannels &lt; 2) {
      WebAudioPlugin.capabilities.panning = false;
		}
		&#x2F;&#x2F; set up AudioNodes that all of our source audio will connect to
    WebAudioPlugin.dynamicsCompressorNode = WebAudioPlugin.context.createDynamicsCompressor();
    WebAudioPlugin.dynamicsCompressorNode.connect(WebAudioPlugin.context.destination);
    WebAudioPlugin.gainNode = WebAudioPlugin.context.createGainNode();
    WebAudioPlugin.gainNode.connect(WebAudioPlugin.dynamicsCompressorNode);
	}

  return WebAudioPlugin;

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>