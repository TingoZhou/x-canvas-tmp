<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/EaselJS_16x16.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
	<title>xc v0.1.0 API Documentation : ..\src\lib\createjs\easeljs\utils\SpriteSheetBuilder.js</title>  
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http:&#x2F;&#x2F;www.createjs.com&#x2F;#!&#x2F;EaselJS"><img src="http:&#x2F;&#x2F;createjs.com&#x2F;resources&#x2F;SuiteIcons&#x2F;EaselJS&#x2F;docs-icon-EaselJS.png" title="xc"></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AlphaMapFilter.html">AlphaMapFilter</a></li>
            
                <li><a href="..&#x2F;classes/AlphaMaskFilter.html">AlphaMaskFilter</a></li>
            
                <li><a href="..&#x2F;classes/Bitmap.html">Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/BitmapAnimation.html">BitmapAnimation</a></li>
            
                <li><a href="..&#x2F;classes/BoxBlurFilter.html">BoxBlurFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorFilter.html">ColorFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrix.html">ColorMatrix</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrixFilter.html">ColorMatrixFilter</a></li>
            
                <li><a href="..&#x2F;classes/Command.html">Command</a></li>
            
                <li><a href="..&#x2F;classes/Container.html">Container</a></li>
            
                <li><a href="..&#x2F;classes/CSSPlugin.html">CSSPlugin</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="..&#x2F;classes/Ease.html">Ease</a></li>
            
                <li><a href="..&#x2F;classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/Filter.html">Filter</a></li>
            
                <li><a href="..&#x2F;classes/Graphics.html">Graphics</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioLoader.html">HTMLAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/HTMLAudioPlugin.html">HTMLAudioPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Log.html">Log</a></li>
            
                <li><a href="..&#x2F;classes/Matrix2D.html">Matrix2D</a></li>
            
                <li><a href="..&#x2F;classes/MotionGuidePlugin.html">MotionGuidePlugin</a></li>
            
                <li><a href="..&#x2F;classes/MouseEvent.html">MouseEvent</a></li>
            
                <li><a href="..&#x2F;classes/MovieClip.html">MovieClip</a></li>
            
                <li><a href="..&#x2F;classes/MovieClipPlugin.html">MovieClipPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Shadow.html">Shadow</a></li>
            
                <li><a href="..&#x2F;classes/Shape.html">Shape</a></li>
            
                <li><a href="..&#x2F;classes/Sound.html">Sound</a></li>
            
                <li><a href="..&#x2F;classes/SoundChannel.html">SoundChannel</a></li>
            
                <li><a href="..&#x2F;classes/SoundInstance.html">SoundInstance</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetBuilder.html">SpriteSheetBuilder</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetUtils.html">SpriteSheetUtils</a></li>
            
                <li><a href="..&#x2F;classes/Stage.html">Stage</a></li>
            
                <li><a href="..&#x2F;classes/TagPool.html">TagPool</a></li>
            
                <li><a href="..&#x2F;classes/Text.html">Text</a></li>
            
                <li><a href="..&#x2F;classes/Ticker.html">Ticker</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Touch.html">Touch</a></li>
            
                <li><a href="..&#x2F;classes/Tween.html">Tween</a></li>
            
                <li><a href="..&#x2F;classes/UID.html">UID</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioLoader.html">WebAudioLoader</a></li>
            
                <li><a href="..&#x2F;classes/WebAudioPlugin.html">WebAudioPlugin</a></li>
            
                <li><a href="..&#x2F;classes/xc.class.html">xc.class</a></li>
            
                <li><a href="..&#x2F;classes/xc.module.html">xc.module</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/xc.html">xc</a></li>
            
                <li><a href="..&#x2F;modules/xc.core.html">xc.core</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.html">xc.createjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.easeljs.html">xc.createjs.easeljs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.soundjs.html">xc.createjs.soundjs</a></li>
            
                <li><a href="..&#x2F;modules/xc.createjs.tweenjs.html">xc.createjs.tweenjs</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
	var name = ..\src\lib\createjs\easeljs\utils\SpriteSheetBuilder.js      
</script>
<h1 class="file-heading">File:..\src\lib\createjs\easeljs\utils\SpriteSheetBuilder.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
xc.module.define(&quot;xc.createjs.SpriteSheetBuilder&quot;, function(exports) {

  var EventDispatcher = xc.module.require(&quot;xc.createjs.EventDispatcher&quot;);
  var Rectangle = xc.module.require(&quot;xc.createjs.Rectangle&quot;);
  var SpriteSheet = xc.module.require(&quot;xc.createjs.SpriteSheet&quot;);

  &#x2F;**
   * The SpriteSheetBuilder allows you to generate sprite sheets at run time from any display object. This can allow
   * you to maintain your assets as vector graphics (for low file size), and render them at run time as sprite sheets
   * for better performance.
   *
   * Sprite sheets can be built either synchronously, or asynchronously, so that large sprite sheets can be generated
   * without locking the UI.
   *
   * Note that the &quot;images&quot; used in the generated sprite sheet are actually canvas elements, and that they will be sized
   * to the nearest power of 2 up to the value of &lt;code&gt;maxWidth&lt;&#x2F;code&gt; or &lt;code&gt;maxHeight&lt;&#x2F;code&gt;.
   *
   * @class SpriteSheetBuilder
   * @extends EventDispatcher
   * @constructor
   *&#x2F;
  var SpriteSheetBuilder = EventDispatcher.extend({
    _init: function() {
      this._frames = [];
      this._animations = {};
    },

    &#x2F;**
     * Dispatched when a build completes.
     *
     * @event complete
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     *&#x2F;

    &#x2F;**
     * Dispatched when an asynchronous build has progress.
     *
     * @event complete
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     * @param {Number} progress The current progress value (0-1).
     *&#x2F;

    &#x2F;**
     * The maximum width for the images (not individual frames) in the generated sprite sheet. It is recommended to use
     * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
     * additional images will be created as needed.
     *
     * @property maxWidth
     * @type Number
     * @default 2048
     *&#x2F;
    maxWidth: 2048,

    &#x2F;**
     * The maximum height for the images (not individual frames) in the generated sprite sheet. It is recommended to use
     * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
     * additional images will be created as needed.
     *
     * @property maxHeight
     * @type Number
     * @default 2048
     *&#x2F;
    maxHeight: 2048,

    &#x2F;**
     * The sprite sheet that was generated. This will be null before a build is completed successfully.
     *
     * @property spriteSheet
     * @type SpriteSheet
     *&#x2F;
    spriteSheet: null,

    &#x2F;**
     * The scale to apply when drawing all frames to the sprite sheet. This is multiplied against any scale specified
     * in the addFrame call. This can be used, for example, to generate a sprite sheet at run time that is tailored to
     * the a specific device resolution (ex. tablet vs mobile).
     *
     * @property defaultScale
     * @type Number
     * @default 1
     *&#x2F;
    scale: 1,

    &#x2F;**
     * The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
     *
     * @property padding
     * @type Number
     * @default 1
     *&#x2F;
    padding: 1,

    &#x2F;**
     * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
     * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
     * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
     * Defaults to 0.3.
     *
     * @property timeSlice
     * @type Number
     * @default 0.3
     *&#x2F;
    timeSlice: 0.3,

    &#x2F;**
     * Read-only. A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
     * been initiated.
     *
     * @property progress
     * @type Number
     * @default -1
     *&#x2F;
    progress: -1,

    &#x2F;**
     * @property _frames
     * @protected
     * @type Array
     *&#x2F;
    _frames: null,

    &#x2F;**
     * @property _animations
     * @protected
     * @type Array
     *&#x2F;
    _animations: null,

    &#x2F;**
     * @property _data
     * @protected
     * @type Array
     *&#x2F;
    _data: null,

    &#x2F;**
     * @property _nextFrameIndex
     * @protected
     * @type Number
     *&#x2F;
    _nextFrameIndex: 0,

    &#x2F;**
     * @property _index
     * @protected
     * @type Number
     *&#x2F;
    _index: 0,

    &#x2F;**
     * @property _timerID
     * @protected
     * @type Number
     *&#x2F;
    _timerID: null,

    &#x2F;**
     * @property _scale
     * @protected
     * @type Number
     *&#x2F;
    _scale: 1,

    &#x2F;**
     * Adds a frame to the {{#crossLink &quot;SpriteSheet&quot;}}{{&#x2F;crossLink}}. Note that the frame will not be drawn until you
     * call {{#crossLink &quot;SpriteSheetBuilder&#x2F;build&quot;}}{{&#x2F;crossLink}} method. The optional setup params allow you to have
     * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
     * times, but manipulate it or it&#x27;s children to change it to generate different frames.
     *
     * Note that the source&#x27;s transformations (x, y, scale, rotate, alpha) will be ignored, except for regX&#x2F;Y. To apply
     * transforms to a source object and have them captured in the sprite sheet, simply place it into a {{#crossLink &quot;Container&quot;}}{{&#x2F;crossLink}}
     * and pass in the Container as the source.
     *
     * @method addFrame
     * @param {DisplayObject} source The source {{#crossLink &quot;DisplayObject&quot;}}{{&#x2F;crossLink}}  to draw as the frame.
     * @param {Rectangle} [sourceRect] A {{#crossLink &quot;Rectangle&quot;}}{{&#x2F;crossLink}} defining the portion of the
     *  source to draw to the frame. If not specified, it will look for a &lt;code&gt;getBounds&lt;&#x2F;code&gt; method, bounds property,
     *  or &lt;code&gt;nominalBounds&lt;&#x2F;code&gt; property on the source to use. If one is not found, the frame will be skipped.
     * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
     * @param {Function} [setupFunction] Optional. A function to call immediately before drawing this frame.
     * @param {Array} [setupParams] Parameters to pass to the setup function.
     * @param {Object} [setupScope] The scope to call the setupFunction in.
     * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
     *&#x2F;
    addFrame: function(source, sourceRect, scale, setupFunction, setupParams, setupScope) {
      if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
      var rect = sourceRect || source.bounds || source.nominalBounds;
      if (!rect &amp;&amp; source.getBounds) { rect = source.getBounds(); }
      if (!rect) { return null; }
      scale = scale || 1;
      return this._frames.push({source: source, sourceRect: rect, scale: scale, funct: setupFunction, params: setupParams, scope: setupScope, index: this._frames.length, height: rect.height *
          scale}) - 1;
    },

    &#x2F;**
     * Adds an animation that will be included in the created sprite sheet.
     *
     * @method addAnimation
     * @param {String} name The name for the animation.
     * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
     *  that played frame indexes 3, 6, and 5 in that order.
     * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
     *  also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
     * @param {Number} [frequency] Specifies a frame advance frequency for this animation. For example, a value
     *  of 2 would cause the animation to advance every second tick.
     *&#x2F;
    addAnimation: function(name, frames, next, frequency) {
      if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
      this._animations[name] = {frames: frames, next: next, frequency: frequency};
    },

    &#x2F;**
     * This will take a MovieClip, and add its frames and labels to this builder. Labels will be added as an animation
     * running from the label index to the next label. For example, if there is a label named &quot;foo&quot; at frame 0 and a label
     * named &quot;bar&quot; at frame 10, in a MovieClip with 15 frames, it will add an animation named &quot;foo&quot; that runs from frame
     * index 0 to 9, and an animation named &quot;bar&quot; that runs from frame index 10 to 14.
     *
     * Note that this will iterate through the full MovieClip with actionsEnabled set to false, ending on the last frame.
     *
     * @method addMovieClip
     * @param {MovieClip} source The source MovieClip to add to the sprite sheet.
     * @param {Rectangle} [sourceRect] A {{#crossLink &quot;Rectangle&quot;}}{{&#x2F;crossLink}} defining the portion of the source to
     *  draw to the frame. If not specified, it will look for a &lt;code&gt;getBounds&lt;&#x2F;code&gt; method, &lt;code&gt;frameBounds&lt;&#x2F;code&gt;
     *  Array, &lt;code&gt;bounds&lt;&#x2F;code&gt; property, or &lt;code&gt;nominalBounds&lt;&#x2F;code&gt; property on the source to use. If one is not
     *  found, the MovieClip will be skipped.
     * @param {Number} [scale=1] The scale to draw the movie clip at.
     *&#x2F;
    addMovieClip: function(source, sourceRect, scale) {
      if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
      var rects = source.frameBounds;
      var rect = sourceRect || source.bounds || source.nominalBounds;
      if (!rect &amp;&amp; source.getBounds) { rect = source.getBounds(); }
      if (!rect &amp;&amp; !rects) { return null; }
      var baseFrameIndex = this._frames.length;
      var duration = source.timeline.duration;
      for (var i = 0; i &lt; duration; i++) {
        var r = (rects &amp;&amp; rects[i]) ? rects[i] : rect;
        this.addFrame(source, r, scale, function(frame) {
          var ae = this.actionsEnabled;
          this.actionsEnabled = false;
          this.gotoAndStop(frame);
          this.actionsEnabled = ae;
        }, [i], source);
      }
      var labels = source.timeline._labels;
      var lbls = [];
      for (var n in labels) {
        lbls.push({index: labels[n], label: n});
      }
      if (lbls.length) {
        lbls.sort(function(a, b) { return a.index - b.index; });
        for (var i = 0, l = lbls.length; i &lt; l; i++) {
          var label = lbls[i].label;
          var start = baseFrameIndex + lbls[i].index;
          var end = baseFrameIndex + ((i == l - 1) ? duration : lbls[i + 1].index);
          var frames = [];
          for (var j = start; j &lt; end; j++) { frames.push(j); }
          this.addAnimation(label, frames, true); &#x2F;&#x2F; for now, this loops all animations.
        }
      }
    },

    &#x2F;**
     * Builds a SpriteSheet instance based on the current frames.
     *
     * @method build
     * @return SpriteSheet The created SpriteSheet instance, or null if a build is already running or an error occurred.
     *&#x2F;
    build: function() {
      if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
      this._startBuild();
      while (this._drawNext()) {}
      this._endBuild();
      return this.spriteSheet;
    },

    &#x2F;**
     * Asynchronously builds a {{#crossLink &quot;SpriteSheet&quot;}}{{&#x2F;crossLink}} instance based on the current frames. It will
     * run 20 times per second, using an amount of time defined by &lt;code&gt;timeSlice&lt;&#x2F;code&gt;. When it is complete it will
     * call the specified callback.
     *
     * @method buildAsync
     * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
     *&#x2F;
    buildAsync: function(timeSlice) {
      if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
      this.timeSlice = timeSlice;
      this._startBuild();
      var _this = this;
      this._timerID = setTimeout(function() { _this._run(); },
          50 - Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)) * 50);
    },

    &#x2F;**
     * Stops the current asynchronous build.
     *
     * @method stopAsync
     *&#x2F;
    stopAsync: function() {
      clearTimeout(this._timerID);
      this._data = null;
    },

    &#x2F;**
     * SpriteSheetBuilder instances cannot be cloned.
     *
     * @method clone
     *&#x2F;
    clone: function() {
      throw(&quot;SpriteSheetBuilder cannot be cloned.&quot;);
    },

    &#x2F;**
     * Returns a string representation of this object.
     *
     * @method toString
     * @return {String} a string representation of the instance.
     *&#x2F;
    toString: function() {
      return &quot;[SpriteSheetBuilder]&quot;;
    },

    &#x2F;**
     * @method _startBuild
     * @protected
     *&#x2F;
    _startBuild: function() {
      var pad = this.padding || 0;
      this.progress = 0;
      this.spriteSheet = null;
      this._index = 0;
      this._scale = this.scale;
      var dataFrames = [];
      this._data = {
        images: [],
        frames: dataFrames,
        animations: this._animations &#x2F;&#x2F; TODO: should we &quot;clone&quot; _animations in case someone adds more animations after a build?
      };
      var frames = this._frames.slice();
      frames.sort(function(a, b) { return (a.height &lt;= b.height) ? -1 : 1; });
      if (frames[frames.length - 1].height + pad * 2 &gt; this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
      var y = 0, x = 0;
      var img = 0;
      while (frames.length) {
        var o = this._fillRow(frames, y, img, dataFrames, pad);
        if (o.w &gt; x) { x = o.w; }
        y += o.h;
        if (!o.h || !frames.length) {
          var canvas = document.createElement(&quot;canvas&quot;);
          canvas.width = this._getSize(x, this.maxWidth);
          canvas.height = this._getSize(y, this.maxHeight);
          this._data.images[img] = canvas;
          if (!o.h) {
            x = y = 0;
            img++;
          }
        }
      }
    },

    &#x2F;**
     * @method _fillRow
     * @protected
     * @return {Number} The width &amp; height of the row.
     *&#x2F;
    _getSize: function(size, max) {
      var pow = 4;
      while (Math.pow(2, ++pow) &lt; size) {}
      return Math.min(max, Math.pow(2, pow));
    },

    &#x2F;**
     * @method _fillRow
     * @protected
     * @return {Number} The width &amp; height of the row.
     *&#x2F;
    _fillRow: function(frames, y, img, dataFrames, pad) {
      var w = this.maxWidth;
      var maxH = this.maxHeight;
      y += pad;
      var h = maxH - y;
      var x = pad;
      var height = 0;
      for (var i = frames.length - 1; i &gt;= 0; i--) {
        var frame = frames[i];
        var sc = this._scale * frame.scale;
        var rect = frame.sourceRect;
        var source = frame.source;
        var rx = Math.floor(sc * rect.x - pad);
        var ry = Math.floor(sc * rect.y - pad);
        var rh = Math.ceil(sc * rect.height + pad * 2);
        var rw = Math.ceil(sc * rect.width + pad * 2);
        if (rw &gt; w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
        if (rh &gt; h || x + rw &gt; w) { continue; }
        frame.img = img;
        frame.rect = new Rectangle(x, y, rw, rh);
        height = height || rh;
        frames.splice(i, 1);
        dataFrames[frame.index] = [
          x, y, rw, rh, img, Math.round(-rx + sc * source.regX - pad), Math.round(-ry + sc * source.regY - pad)
        ];
        x += rw;
      }
      return {w: x, h: height};
    },

    &#x2F;**
     * @method _endBuild
     * @protected
     *&#x2F;
    _endBuild: function() {
      this.spriteSheet = new SpriteSheet(this._data);
      this._data = null;
      this.progress = 1;
      this.dispatchEvent(&quot;complete&quot;);
    },

    &#x2F;**
     * @method _run
     * @protected
     *&#x2F;
    _run: function() {
      var ts = Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)) * 50;
      var t = (new Date()).getTime() + ts;
      var complete = false;
      while (t &gt; (new Date()).getTime()) {
        if (!this._drawNext()) {
          complete = true;
          break;
        }
      }
      if (complete) {
        this._endBuild();
      } else {
        var _this = this;
        this._timerID = setTimeout(function() { _this._run(); }, 50 - ts);
      }
      var p = this.progress = this._index &#x2F; this._frames.length;
      this.dispatchEvent({type: &quot;progress&quot;, progress: p});
    },

    &#x2F;**
     * @method _drawNext
     * @protected
     * @return Boolean Returns false if this is the last draw.
     *&#x2F;
    _drawNext: function() {
      var frame = this._frames[this._index];
      var sc = frame.scale * this._scale;
      var rect = frame.rect;
      var sourceRect = frame.sourceRect;
      var canvas = this._data.images[frame.img];
      var ctx = canvas.getContext(&quot;2d&quot;);
      frame.funct &amp;&amp; frame.funct.apply(frame.scope, frame.params);
      ctx.save();
      ctx.beginPath();
      ctx.rect(rect.x, rect.y, rect.width, rect.height);
      ctx.clip();
      ctx.translate(Math.ceil(rect.x - sourceRect.x * sc), Math.ceil(rect.y - sourceRect.y * sc));
      ctx.scale(sc, sc);
      frame.source.draw(ctx); &#x2F;&#x2F; display object will draw itself.
      ctx.restore();
      return (++this._index) &lt; this._frames.length;
    }
  });

  SpriteSheetBuilder.ERR_DIMENSIONS = &quot;frame dimensions exceed max spritesheet dimensions&quot;;
  SpriteSheetBuilder.ERR_RUNNING = &quot;a build is already running&quot;;

  return SpriteSheetBuilder;

});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>