<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>EaselJS Example: Rollovers and Drag & Drop</title>

<link href="assets/demoStyles.css" rel="stylesheet" type="text/css" />

<script type="text/javascript" src="../../../src/xc.js"></script>

<script>
xc.depends([
    "../../../src/core",
    "../../../src/lib/createjs"
], function() {

    var Stage = xc.module.require("xc.createjs.Stage");
    var Shape = xc.module.require("xc.createjs.Shape");
    var Bitmap = xc.module.require("xc.createjs.Bitmap");
    var Container = xc.module.require("xc.createjs.Container");
    var Ticker = xc.module.require("xc.createjs.Ticker");
    var Touch = xc.module.require("xc.createjs.Touch");

	var canvas, stage;

	var mouseTarget;	// 标识在鼠标下或正在被拖动的显示对象。
	var dragStarted;	// 指出我们当前是否正在进行拖动操作。
	var offset;
	var update = true;

	function init() {
		if (window.top != window) {
			document.getElementById("header").style.display = "none";
		}
		document.getElementById("loader").className = "loader";
		// 创建一个 stage 对象并指向 canvas。
		canvas = document.getElementById("testCanvas");

		// 检查当前浏览器是否支持 touch 事件。
		stage = new Stage(canvas);

		// 如果当前设备支持 touch 事件，将其启用。
		Touch.enable(stage);

        stage.mouseMoveOutside = true; // 设置当鼠标离开 canvas 时，仍跟踪鼠标。
		// 启用 mouseover 事件。
		stage.enableMouseOver(10);

		// 加载资源图片。
		var image = new Image();
		image.src = "assets/daisy.png";
		image.onload = handleImageLoad;
	}

	function stop() {
		Ticker.removeEventListener("tick", tick);
	}

	function handleImageLoad(event) {
		var image = event.target;
		var imgW = image.width;
		var imgH = image.height;
		var bitmap;
		var container = new Container();
		stage.addChild(container);
		
	    // 创建一个代表雏菊图片中心的 shape 对象。
		var hitArea = new Shape();
		hitArea.graphics.beginFill("#FFF").drawEllipse(-11,-14,24,18);
		// 设置目标对象的 hitArea 坐标，该坐标系相对于目标对象（bitmap 实例）。
		hitArea.x = imgW/2;
		hitArea.y = imgH/2;

		// 创建随机位置的雏菊图片，并填充满整个屏幕。
		for(var i = 0; i < 100; i++){
			bitmap = new Bitmap(image);
			container.addChild(bitmap);
			bitmap.x = canvas.width * Math.random()|0;
			bitmap.y = canvas.height * Math.random()|0;
			bitmap.rotation = 360 * Math.random()|0;
			bitmap.regX = imgW/2|0;
			bitmap.regY = imgH/2|0;
			bitmap.scaleX = bitmap.scaleY = bitmap.scale = Math.random()*0.4+0.6;
			bitmap.name = "bmp_"+i;

            bitmap.cursor = "pointer";
			
			// 分配 hitArea 区域到没一个 bitmap 实例。
			bitmap.hitArea = hitArea;

			// 封装用于提供事件处理的方法。
			(function(target) {
				bitmap.addEventListener("mousedown", function(evt) {
					// 调整目标对象到所有子对象的最前面。
					container.addChild(target);
					var offset = {x:target.x-evt.stageX, y:target.y-evt.stageY};

					// 对目标对象监听 mousemove 事件。
				    // 这将在用户松开鼠标按钮之前都是有效的。
					evt.addEventListener("mousemove", function(ev) {
						target.x = ev.stageX+offset.x;
						target.y = ev.stageY+offset.y;
						// 设置 stage 在下一个 tick 里需要更新。
						update = true;
					});
				});
				bitmap.addEventListener("mouseover", function() {
					target.scaleX = target.scaleY = target.scale*1.2;
					update = true;
				});
				bitmap.addEventListener("mouseuut", function() {
					target.scaleX = target.scaleY = target.scale;
					update = true;
				});
			})(bitmap);
		}

		document.getElementById("loader").className = "";
		Ticker.addEventListener("tick", tick);
	}

	function tick() {
		// 这里通过 update 属性控制 stage 只在有子对象绑定了事件的时候才需要更新。
		if (update) {
			update = false; // 设置只更新一次
			stage.update();
		}
	}

    init();
});
</script>
</head>

<body>
	<center>
		<div id="loader"></div>
		<header id="header" class="EaselJS">
		    <h1><span class="text-product">Easel<strong>JS</strong></span> 实现带有点击区域的拖动效果</h1>
		    <p>该例子与拖动效果的例子是相似的，只是额外添加了 <strong>hitArea</strong> 属性，使得只有雏菊图像的中间才能响应鼠标事件，从而拖动图像。</p>
		</header>
		<div class="canvasHolder">
			<canvas id="testCanvas" width="960" height="400"></canvas>
		</div>
	</center>
</body>
</html>
